=pod

=head1 Features

=head2 Tentative Version Changes

=item 0.1.7

Introduce the object interface, tension setting for slack and buffer, fixed next[0] handling, fixed/improved non-deterministic tests.

=item 0.1.8

Tension settings that are I<configurable>.  Introduce commandline, compile mode and pre-scheduling safety checks.

=item 0.1.9

C<buildSchedule> should warn about deprecation, TBD...

=item 0.2.0

Switch to the object-only interface.

=head2 Scheduling

Multiple proposals are being considered for rescheduling, scheduling adjustment to target different attributes, as well as attribute-level goals.  Other feature improvements below are related to scheduling.

=head2 Message support

No additional features planned.  Messages can be strings, arrays, a hash of alternates, a named message key, or a hash named message.  Named messages are supported for action nodes and annotations.  Attributes are supported in hash-alternate configurations and within named messages.

=head2 Attributes

Planned improvements include helpers to merge annotation attributes into schedules, additional reporting functions, and automatic mapping of attributes for some action node parameters (eg limits).  As of 0.1.2, attributes are fully supported in messages and action nodes.  As of 0.1.3, precedence has been established for node/message attribute overlap.  As of 0.1.5, average values have moved to a rolling algorithm to improve efficiency, which means that no historic/past entry of a value is possible.

=head2 Annotations

Planned improvements include helpers to merge annotation attributes into schedules.  Proposed is annotation configuration per-node (with a keyname, possibly duplicated in the upper-level configuration).  As of 0.1.2, annotation groups are fully supported.

=head2 Node filtering

Node filtering is experimental starting in 0.1.6.  Filters support Booleans and attribute numeric comparisons.  Average value filtering should work but is not well tested.  Because per-node limits differ between limit-per-activity and limit-per-schedule, it's not clear that a special mechanism will be created to provide these limits, which can be achieved by setting the attribute to zero at the appropriate point and filtering normally.

=head2 Near-buffer limitation

Fixed in 0.1.7.  See L<Schedule::Activity/BUGS>.  If a conclusion node can be reached, there are more circumstances where it should be chosen to complete scheduling.  The arithmetic for available buffer time should be updated to include the tmmax of the final node, where applicable.

=head2 Tutorial

In addition to the samples listed below, a tutorial is planned to take an existing, linear schedule, and deconstruct it into activities/actions, messages, and annotation groups.  As of 0.1.6, work has begun on a tutorial!

=head2 Action limits

The case C<limit=1> is not the primary/initial use case of this scheduler, but some events will likely never be repeated.  This can already be achieved by setting the attribute to zero initially, incrementing as appropriate, and then filtering.  Because there's a difference between limit-per-activity and limit-per-schedule, it's not clear that a special mechanism will be created.

=head2 Tension configuration

Partially available in 0.1.7.  Scheduling tension is currently only available for buffer time, but it should also be configurable for slack time.  In 0.1.7, tension settings affect path selection, but the scheduler will fail for the fullpath if there is insufficient slack/buffer to adjust the path to the goal time.  This may change in the future, namely the tension settings may permit scheduling completion even if the measured slack/buffer wouldn't otherwise permit adjustment.

=head2 Slack/buffer defaults

As an improvement, support passing slack/buffer ratios during configuration building.  Eventually it will be helpful to pass slack/buffer defaults as part of schedule building:  Having a value used during schedule building would permit relaxation during retries, and could be reported with the result.  This requires changing assumptions in the validators.

=head2 Pre-scheduling safety

Built in 0.1.7 but undocument and not currently part of the required compile step.  Convenience helpers for min/max/valid reporting.  More complex schedules may be difficult to interpret at a glance.  One particular annoyance is finding that the target time for an activity cannot be reached, or that there are too many actions to fit a smaller goal window.  Recommend some convenience functions to find the minimum possible activity time (shortest path through the nodes, ultimately), if the activity can be completed at all (sorta easy to forget, and should be checked before attempting scheduling), and the maximum possible activity time (if defined).  Moreover, these checks are needed to avoid hanging nodes (that don't reach finish), or action nodes with zero times (that never make progress).

=head2 Script-based tooling

Scripts can be provided for common scheduling needs.  Music playlists (high count, non-redundant nodes), exercise schedules (chunking, some repeats), chores/errands (small action count per activity/category), games (rounds, countdown reminders).

=head2 Markdown

Basic Markdown support is likely to change in non-backwards-compatible ways.  A written proposal might be posted to ensure support for the common use cases that would aide with faster definitions and imports.

=head2 Sample text to speech tool

An HTML+Javascript solution utilizing Web text to speech already exists to handle reminders for schedules of the form C<hh:mm:ss message # comment> and could be provided in C<samples/>.

=head2 Additional samples

There are three use cases that cannot currently be provided as examples.

First, something like a music playlist is similar to the base case here.  This is a "large number of random choices" but "each is very fixed in time length".  There are multiple potential actions to be randomized.  Music has attributes (mood).  Scheduling can be arranged in chunks (activities), so there are natural groupings for an arrangement.  Scheduling requires Action limits, above, so currently this is slightly difficult and/or requires a helper import mechanism to build the schedules.  Moreover, the slack/buffer mechanisms operate 'backwards', in the sense that music+pause periods are fixed and may be impossible to schedule within a fixed/given window of time (hence the common patterns of advertisements between songs and fade-in/out techniques).  It's not clear that an arithmetic equivalent of fading will ever be supported in this library.  Nevertheless, a "playlist import" type mechanism to build the configurations would be helpful.

Second, something like holiday activities.  This is a "small number of choices" but "each is very fluid in length" and has C<limit=1>.  An import tool for this type of request should be rather easy, but Action limits are a prerequisite.

Third, scheduling of paired events is not straightforward.  An example would be match-off lineups of N teams (eg fantasy leagues).  That is less a concern of temporal scheduling and more about uniformity in the lineup.  This is possible by running two simultaneous builders on the same configuration, with very fixed times, but may result in self-alignment of activities.  It's not clear that this type of scheduling will ever be supported in this library.

=head1 Functional improvements

=head2 Validation and configuration build

Attribute registration is getting messy; needs more helpers, particularly for pulling attributes out of message objects.  Validation of named messages, and even messages themselves, is flakey.

=head2 Object interface

Move C<Schedule::Activity> from static functions to an object interface.  This is likely to occur when moving to 0.2.0.

=head2 Pre-scheduling validation

Scheduling shouldn't be attempted if it's impossible to achieve the goals.  As per the suggested convenience functions above, verify that the minimum path time and max path times bound the activity goal time.

=head2 Annotation validation

Annotations need better pre-scheduling validation and better separation from the main scheduling code.  Currently unclear of the best place to provide those helpers, as well as annotation-group-merging functions and the associated configurations.

=head2 Slackless/Bufferless configurations

Goals can never be met if slack/buffers are zero and the activity time requested doesn't exactly match action choices.  This should likely fail with an error similar to the convenience functions mentioned above.

=head2 Support full object configurations

The current validation logic assumes plain hash references in several spots, but a user should be able to build an object-oriented collection of Nodes etcetera and still call schedule, without manually overriding the pre-validation flag.

=head2 Backtracking behavior

The current mechanism is primarily for safety.  Better backtracking support should be possible.

=head2 Validation of tmmin/avg/max

Validation should check that values are non-decreasing.

=cut
